<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="utf-8">
   <title>OpenStreetMap Example - Geocoding</title>
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.4/socket.io.js" integrity="sha512-aMGMvNYu8Ue4G+fHa359jcPb1u+ytAF+P2SCb+PxrjCdO3n3ZTxJ30zuH39rimUggmTwmh2u7wvQsDTHESnmfQ==" crossorigin="anonymous"></script>

  <!-- <link rel="stylesheet" type="text/css" href="./static/style.css"> -->
  <style>
               body {
               margin: 0;
               padding: 0;
               font-family: Arial, sans-serif;
               overflow-x: hidden;
               /* display:  flex; */
               /* Hide horizontal scrollbar on smaller screens */
           }

           .header {
               display: flex;
               justify-content: space-between;
               align-items: center;
               padding: 10px;
               background-color: #f0f0f0;
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
               /* Add shadow for better visual */
               position: fixed;
               /* Fixed header */
               width: 100%;
               /* Full width */
               z-index: 1000;
               /* Ensure header stays on top of other content */
           }

           .input-container {
               display: flex;
               flex-wrap: wrap;
               /* Allow elements to wrap to the next line on smaller screens */
               justify-content: center;
               align-items: center;
               padding: 10px;
               background-color: #f0f0f0;
               margin-top: 60px;
               /* Adjust margin to accommodate fixed header */
           }

           .map-container {
               position: relative;
               overflow: hidden;
           }

           #map {
               width: 100%;
               height: 800px;
               /* Set initial height for map */
           }

            label {
                display: block;
                margin-bottom: 5px;
                color: #555;
            }
                
           input {
               margin-bottom: 10px;
               /* Add some space between input elements */
               padding: 10px;
               border: 1px solid #ccc;
               border-radius: 5px;
               outline: none;
               width: calc(50% - 20px);
               /* Adjust width to fit two inputs in a row */
               max-width: 300px;
               /* Limit max width for larger screens */
           }

           button {
               margin-bottom: 10px;
               /* Add some space between button elements */
               padding: 10px 20px;
               background-color: #4CAF50;
               color: white;
               border: none;
               border-radius: 5px;
               cursor: pointer;
               width: calc(50% - 20px);
               /* Adjust width to fit two buttons in a row */
               max-width: 300px;
               /* Limit max width for larger screens */
           }

           button:hover {
               background-color: #45a049;
           }
           
            #instructions-container {
                width: 300px;
                padding: 10px;
                box-sizing: border-box;
                margin-top: 1px;
                margin-right: 30px;
                background-color: #fff;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                z-index: 1000;
                position: absolute;
                top: 20px;
                right: 20px;
            }
  </style>
</head>


<body>
   <div class="map-container">
      <div id="map"></div>
   </div>

   <div class="input-container">
      <label for="startAddress">Start Address:</label>
      <input type="text" id="startAddress" placeholder="Choose starting point">
      <button id="location" onclick="getGeolocation()">Get Current Location</button>
      <h1></h1>
      <p id="locationData"></p>
      <label for="endAddress">End Address:</label>
      <input type="text" id="endAddress" placeholder="Choose destination">
      <button onclick="directions()">Directions</button>
      <div id="shortestDistance">Distance:</div>
      <div id="time">Time:</div>

   </div>

      <div id="instructions-container">
         <h3>Instructions:</h3>
         <ul id="instructions-list"></ul>
      </div>
   <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
   <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.min.js"></script> -->

  <script>
         const map = L.map('map').setView([28.7041, 77.1025], 12);
         
         L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
             attribution: 'Â© OpenStreetMap contributors'
         }).addTo(map);
         
         
         /*const startIcon = L.icon({
             iconUrl: 'https://leafletjs.com/examples/custom-icons/leaf-green.png', // Replace with the URL to your custom start marker icon
             iconSize: [38, 95],
             iconAnchor: [22, 94],
             popupAnchor: [-3, -76],
         });
         */

         var greenIcon = new L.Icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                //shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            });

             var redIcon = new L.Icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                //shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            });
         
         const endIcon = L.icon({
             iconUrl: 'https://leafletjs.com/examples/custom-icons/leaf-red.png', // Replace with the URL to your custom end marker icon
             iconSize: [38, 95],
             iconAnchor: [22, 94],
             popupAnchor: [-3, -76],
         });
         

       
        //receive details from server
        var socket = io.connect();



         // to get current marker position
         function centerLeafletMapOnMarker(map, marker) {
             var latLngs = [ marker.getLatLng() ];
             var markerBounds = L.latLngBounds(latLngs);
             map.fitBounds(markerBounds);
           }

         
         var getCurrentLocationCalled = false;
         var current_gps_lat = 0;
         var current_gps_lon = 0;
         
         // Function for getting the current Location of user

        function getGeolocation(){



            socket.on("gps_data", function (msg) {

                if(getCurrentLocationCalled == false){


                console.log("Inside gps_data socket ")
                console.log("Received sensorData :: " + msg.latitude + " :: " + msg.longitude);
                console.log("Inside Get POsition function");
                console.log(msg);
                var latitude = msg.latitude;
                var longitude = msg.longitude;

                current_gps_lat = msg.latitude;
                current_gps_lon = msg.longitude;
                var accuracy = 5;
                document.getElementById('startAddress').value = `${latitude}, ${longitude}`;
                
                // Adding marker and circle of accuracy of current location on Map 
                var marker = L.marker([latitude, longitude], {icon: greenIcon});
                var circle = L.circle([latitude, longitude], {radius: accuracy});
            
                var featureGroup = L.featureGroup([marker, circle]).addTo(map);
                map.fitBounds(featureGroup.getBounds());
                getCurrentLocationCalled = true;
                }

                                                
            });
            return;


        }

        
        


         /*
         function getGeolocation(){
             getCurrentLocationCalled = true;

             // Old browser are not Compaitable for this service
             if(!navigator.geolocation){
                 console.log("Browser Not Compaitable");
             }
             else{
                 navigator.geolocation.getCurrentPosition(getPosition);
         
             }
         }
         */
         
         
         // Function to extract the information need from the below Structure

         /* 
         GeolocationPositioncoords: GeolocationCoordinatesaccuracy: 17.127
         altitude: null
         altitudeAccuracy: null
         heading: null
         latitude: 28.4832428
         longitude: 77.1044168
         speed: null
         [[Prototype]]: GeolocationCoordinates
         timestamp: 1708061729187
         [[Prototype]]: GeolocationPosition
         */
         

         /*
         function getPosition(position){
            console.log("Inside Get POsition function");
             console.log(position);
             var latitude = position.coords.latitude;
             var longitude = position.coords.longitude;
             var accuracy = position.coords.accuracy;
             document.getElementById('startAddress').value = `${latitude}, ${longitude}`;
            
             // Adding marker and circle of accuracy of current location on Map 
             var marker = L.marker([latitude, longitude], {icon: greenIcon});
             var circle = L.circle([latitude, longitude], {radius: accuracy});
         
             var featureGroup = L.featureGroup([marker, circle]).addTo(map);
             map.fitBounds(featureGroup.getBounds());
         
         }

         */
         
         
         // Function to recentre the Map (Not using right now)
         function recenterMap() {
             // Get the marker's position
             var markerLatLng = L.latLng(document.getElementById('startAddress').value.split(',').map(coord => parseFloat(coord.trim())));
         
             // Center the map on the marker's position
             map.panTo(markerLatLng);
         }
         

         
         // Function to send the soruce and destination coordinate to the server and recieve the response.
         function directions() {
             const startAddress = document.getElementById('startAddress').value;
             console.log("start adress" , startAddress);
             const endAddress = document.getElementById('endAddress').value;
            
             // Coordinates from the geolocation()
             const startCoordinates = startAddress.split(',').map(coord => parseFloat(coord.trim()));
             console.log(startCoordinates);
         
             var sourceLat;
             var sourceLon;
             console.log(getCurrentLocationCalled)
             if(!getCurrentLocationCalled){

                
                // Geocoding Api called for get the coodinates form Address
                 fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(startAddress)}&format=json`)
                 .then(response => response.json())
                 .then(data => {
                     sourceLat = parseFloat(data[0].lat);
                     console.log("source lat ", sourceLat)
                     sourceLon = parseFloat(data[0].lon);
                     console.log("source lon ", sourceLon)
                     console.log("Nominatim for Start address is called")
             }).catch(error => console.error('Error:', error));
         }
             else{
                 sourceLat = startCoordinates[0];
                 sourceLon = startCoordinates[1];
             }
         
         
                     fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(endAddress)}&format=json`)
                         .then(response => response.json())
                         .then(data => {
                             const destLat = parseFloat(data[0].lat);
                             const destLon = parseFloat(data[0].lon);
                            
                            // Add marker to the start and end position
                             const startMarker = L.marker([sourceLat, sourceLon], {icon: greenIcon}).addTo(map);
                             const endMarker = L.marker([destLat, destLon], {icon:redIcon}).addTo(map);        
                          
         
         
                             fetch('/process_coordinates', {
                                 method: 'POST',
                                 headers: {
                                     'Content-Type': 'application/json',
                                 },
                                 body: JSON.stringify({
                                     sourceLat: sourceLat,
                                     sourceLon: sourceLon,
                                     destLat: destLat,
                                     destLon: destLon
                                 }),
                             })
                             .then(response => response.json())
                             .then(data => { // recieve response back from server
                                 const pathCoordinates = data.path;
                                 console.log("Path Coordinates : ", pathCoordinates);

                                 const instr = data.instruction;
                                 console.log("Instructions : ", instr)

                                // For debugging
                                 map.eachLayer(layer => {
                                     if (layer instanceof L.CircleMarker) {
                                         map.removeLayer(layer);
                                     }
                                 });
                                 let traveledPathPolyline; // To make the travalled path

                                 // Path from the coordinates obtained from server 
                                 const pathPolyline = L.polyline(pathCoordinates, {color: '#0F53FF' ,weight: 8}).addTo(map);
                                 map.fitBounds(pathPolyline.getBounds());
                                 //map.setZoom(18);
         
                                 traveledPathPolyline = L.polyline([], { color: '#F1C40F', weight: 8 }).addTo(map);
                                
                           
                                const animatedMarker = L.marker([current_gps_lat, current_gps_lon]).addTo(map);
                                 
                                /* New Line */
         
                                 // Set the map view to follow the marker's position
                                 map.setView(pathCoordinates[0], 15); // Adjust the zoom level as needed
         
         
         
                                 const updateInterval = 1000; // Interval for marker moving on the path
                                 const updateGeoLocation = 3000; // for getting current Location in every 20 ms 

                                 // Marking time in format of hh::mm
                                 const timeInSeconds = data.time;
                                 const hours = Math.floor(timeInSeconds / 3600);
                                 const minutes = Math.floor((timeInSeconds % 3600) / 60);
                                 const formattedTime = hours > 0 ? `${hours} hr ${minutes} min` : `${minutes} min`;
         
                                 document.getElementById('time').innerHTML = `Time: ${formattedTime}`;
         
                                 const distance = data.distance;
                                 document.getElementById('shortestDistance').innerHTML = `Distance: ${distance.toFixed(2)} km`;
         
                                 const instruction = data.instruction;
                                 let i = 1;
                                 function extractTurnType(instruction) {
                                        // Check if the instruction contains turn information
                                        const turnKeywords = ['left', 'right', 'straight'];
                                        const instructionWords = instruction.split(' ');
                                        for (const word of instructionWords) {
                                            // Check if the word indicates a turn
                                            if (turnKeywords.includes(word.toLowerCase())) {
                                                // Return the turn type (left, right, or straight)
                                                return word.toLowerCase();
                                            }
                                        }
                                        // If no turn information found, return null
                                        return 'straight';
                                }

                                 // Function to dislay insturction as marker move
                                 function displayInstructions(instruction, sourceLat, sourceLon, distance, verbalPostInstruction ) {
                                    console.log("Instruction: ", instruction);
                                    const turnType = extractTurnType(instruction);
                                    console.log("Turn Type : ", turnType);




                                    console.log("verbalPostInstruction : ", verbalPostInstruction);


                                    //console.log("Source Lon: ", sourceLon);
                                    //console.log("Current Index: ", currentIndex);

                                    let display_marker = L.marker([sourceLat, sourceLon]).addTo(map);
                                  
         
                                    const instructionsList = document.getElementById('instructions-list');
         
                                     instructionsList.innerHTML = ''; // Clear existing instructions
                                    const listItem = document.createElement('li');
                                    listItem.textContent = `${instruction}`;
                                    //listItem.textContent = instruction[currentManeuverIndex].verbal_post_transition_instruction;

                                    //instructionsList.appendChild(listItem);

                                    //const listItem2 = document.createElement('li');
                                    //listItem2.textContent = instruction[currentManeuverIndex].verbal_post_transition_instruction;


                                    //instructionsList.appendChild(listItem2);
                                    
                                        let turnImageUrl = '';
                                        if (turnType === 'left') {
                                            turnImageUrl = './static/left.png'; // Replace with the URL of your left turn image
                                        } else if (turnType === 'right') {
                                            turnImageUrl = './static/right.png'; // Replace with the URL of your right turn image
                                        } else {
                                            turnImageUrl = './static/straight.png'; // Replace with the URL of your straight image
                                        }

                                        if (turnImageUrl) {
                                            const turnImage = document.createElement('img');
                                            turnImage.src = turnImageUrl;
                                            turnImage.alt = turnType === 'left' ? 'Left Turn' : turnType === 'right' ? 'Right Turn' : 'Straight';
                                            turnImage.width = '40';
                                            turnImage.height = '40';
                                            listItem.appendChild(turnImage);
                                            setTimeout(() => {
                                            listItem.removeChild(turnImage);
                                        }, 5000);
                                         }


                                     instructionsList.appendChild(listItem);

                                     /*
                                     if (verbalPostInstruction) {
                                         const postTransitionItem = document.createElement('li');
                                         postTransitionItem.textContent = verbalPostInstruction ;
                                         instructionsList.appendChild(postTransitionItem);
                                     }
                                     */
                                 }
                                 
                                
                                 // Function to calculate diatnce between 2 pair of coordinates
                                 function calculateDistance(lat1, lon1, lat2, lon2) {
                                     
                                     const R = 6371;
                                     const dLat = (lat2 - lat1) * (Math.PI / 180);
                                     const dLon = (lon2 - lon1) * (Math.PI / 180);
                                     const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                                               Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                                     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                                    const distance = R * c; // distance in kilometer
                                    return distance; // distance in meter
         
                                     //var round = parseFloat(distance.toFixed(3));

                                    
                                 }

                                 //console.log("Distance : ", calculateDistance(28.482209, 77.104734, 28.482378, 77.104741), "m");

                                 /*
                                 var current = 0;
                                  const markeronPath = setInterval(() => {
                                                
                                               if(current > pathCoordinates.length){
                                                clearInterval(markeronPath);
                                                return;
                                               }
                                                const animatedMarker = L.marker(pathCoordinates[current], {icon:redIcon}).addTo(map);
                                                 current++;

                                            }, 1000);
                                            */
                                 
                                 // to track the distance travelled by marker
                                 let totalDistanceTraveled = 0;

                                 // Track which instructions are displayed so far
                                 let instructionIndex = 0;
                                 let distanceReqForNextInst=0;
                                 let currentManeuverIndex = 0;
                                 
                                 // Current position of the marker
                                 let currentIndex = 0;
                                 let coordinateIndex = 0;
                                 var marker, circle;

                                // Function to update the current position of the marker from coordinates in a text file
                                
/*
                                function updateMarkerPosition() {
                                    // Fetch coordinates from the text file
                                    fetch('/static/gnss.txt')
                                        .then(response => response.text())
                                        .then(text => {
                                            console.log("Inside Update Marker position");

                                            // Parse the text file content to extract coordinates
                                            const coordinatesArray = text.split('\n').map(line => {
                                                const match = line.match(/Latitude: ([\d.]+) N, Longitude: ([\d.]+) E/);
                                                if (match) {
                                                    // Convert degree minute and second format to degree decimal format
                                                    const latitude = parseFloat(match[1].slice(0, 2)) + parseFloat(match[1].slice(2)) / 60;
                                                    const longitude = parseFloat(match[2].slice(0, 2)) + parseFloat(match[2].slice(2)) / 60;
                                                    return [latitude, longitude];
                                                } else {
                                                    return null; // Handle invalid lines
                                                }
                                            }).filter(coord => coord !== null);

                                            //console.log("Coordinates Array: ", coordinatesArray);

                                            // If marker is present then remove
                                            if (marker) {
                                                map.removeLayer(marker);
                                            }
                                            if (circle) {
                                                map.removeLayer(circle);
                                            }

                                            // Update marker position
                                            let currentMarkerIndex = 0;
                                            const [gpsLatitude, gpsLongitude] = coordinatesArray[currentMarkerIndex];
                                            marker = L.marker([gpsLatitude, gpsLongitude]).addTo(map);

                                            // Update traveled path polyline
                                            traveledPathPolyline.addLatLng([gpsLatitude, gpsLongitude]);
                                            clearInterval(markerUpdate);

                                            const intervalDuration = 1000;

                                            const markerUpdateInterval = setInterval(() => {
                                                currentMarkerIndex++;
                                                if (currentMarkerIndex >= coordinatesArray.length) {
                                                    clearInterval(markerUpdateInterval); // Stop updating when all coordinates are visited
                                                    return;
                                                }
                                                const [latitude, longitude] = coordinatesArray[currentMarkerIndex];

                                                //updateInstruction(latitude, longitude);

                                                marker.setLatLng([latitude, longitude]); // Update marker position
                                                //console.log("Coordinates: ", [latitude, longitude]);
                                                traveledPathPolyline.addLatLng([latitude, longitude]); // Update traveled path polyline
                                            }, intervalDuration);
                                        })
                                        .catch(error => console.error('Error fetching coordinates:', error));
                                }
*/


         
         
                                 function difference(distance1, distance2){
                                     const diff = Math.abs(distance2 - distance1);
                                     return diff < 0.5;
                                 }

                                  socket.on("gps_data", function (msg) {
                                                console.log("Inside gps_data socket ")
                                                //console.log("Received sensorData :: " + msg.latitude + " :: " + msg.longitude);
                                                gps_lat = msg.latitude;
                                                gps_lon = msg.longitude;

                                                updateInstruction(msg.latitude, msg.longitude);
                                                console.log("Update instruction is xcalled ")
                                                //return msg;


                                                
                                            });
         
                                 /*
                                 function updateInstruction(latitude, longitude) {
                                    //console.log("-------------- Befor gps_data -----------")

                                    console.log("Coordinates : ", latitude, " --- - --  ", longitude);
                                    console.log("Current location : ", current_gps_lat, " ----- ", current_gps_lon);

                                    /*
                                    socket.on("gps_data", function (msg) {
                                                console.log("Inside gps_data socket ")
                                                //console.log("Received sensorData :: " + msg.latitude + " :: " + msg.longitude);
                                                gps_lat = msg.latitude;
                                                gps_lon = msg.longitude;

                                                
                                                //return msg;


                                                
                                            });
                                            */
                                    //console.log("-------------- After gps_data -----------")

/*
                                    if (currentIndex < pathCoordinates.length) {

                                        
                                        if(instructionIndex == 0){
                                            displayInstructions(instruction[currentManeuverIndex].instruction, pathCoordinates[currentIndex][0], pathCoordinates[currentIndex][1], instruction[currentManeuverIndex].length , instruction[currentManeuverIndex].verbal_post_transition_instruction);
                                            //displaySupportingInstruction(instruction[currentManeuverIndex].instruction);
                                           

                                            instructionIndex++;
                                            currentIndex++;
                                            //distanceReqForNextInst = instruction[instructionIndex-1].length;
                                            currentManeuverIndex++;
                                            
                                            return;
                                        }
                                        else{

                                            distanceReqForNextInst = instruction[instructionIndex-1].length;
                                            //console.log("distnace required : ", distanceReqForNextInst)

                                            const distanceCoordinates = calculateDistance(pathCoordinates[currentIndex-1][0], pathCoordinates[currentIndex-1][1], 
                                                                                            pathCoordinates[currentIndex][0], pathCoordinates[currentIndex][1]);

                                           //console.log("Index ", currentIndex-1, currentIndex);
                                           //console.log("Distance coordintaes : ", distanceCoordinates.toFixed(3))
                                            totalDistanceTraveled = totalDistanceTraveled + distanceCoordinates;
                                            document.getElementById('instructions-list').innerHTML = `<li>Continue for ${(distanceReqForNextInst.toFixed(2) * 1000) - (totalDistanceTraveled.toFixed(2) * 1000)}  m</li>`;

                                           // console.log("total distance : ", totalDistanceTraveled);

                                        }

                                        
                                        
                                        if (parseFloat(totalDistanceTraveled.toFixed(3)) >= parseFloat(distanceReqForNextInst.toFixed(3))) {
                                            //console.log("Distance Travelled : ", totalDistanceTraveled, "Distance Required : ", distanceReqForNextInst);
                                            displayInstructions(instruction[currentManeuverIndex].instruction, pathCoordinates[currentIndex-1][0], pathCoordinates[currentIndex-1][1], instruction[currentManeuverIndex].length, instruction[currentManeuverIndex].verbal_post_transition_instruction);

                                            totalDistanceTraveled = 0;
                                            //console.log("total distance : ", totalDistanceTraveled);
                                            currentManeuverIndex++;
                                            instructionIndex++;

                                        }
                                    }
                                    currentIndex++;
                                    
                                    
                             }
                             */
                            function updateInstruction(gps_lat, gps_lon) {
                                    console.log("Innside Update instruction")

                                    //console.log("-------------- Befor gps_data -----------")

                                    
                                    //console.log("Coordinates : ", gps_lat, " --- - --  ", gps_lon);
                                    //console.log("Current location : ", current_gps_lat, " ----- ", current_gps_lon);




                                    /*
                                    socket.on("gps_data", function (msg) {
                                                console.log("Inside gps_data socket ")
                                                //console.log("Received sensorData :: " + msg.latitude + " :: " + msg.longitude);
                                                gps_lat = msg.latitude;
                                                gps_lon = msg.longitude;

                                                
                                                //return msg;


                                                
                                            });
                                            */
                                    //console.log("-------------- After gps_data -----------")


                                    //if (currentIndex < pathCoordinates.length) {

                                        
                                        if(instructionIndex == 0){
                                            displayInstructions(instruction[currentManeuverIndex].instruction, current_gps_lat, current_gps_lon, instruction[currentManeuverIndex].length , instruction[currentManeuverIndex].verbal_post_transition_instruction);
                                            //displaySupportingInstruction(instruction[currentManeuverIndex].instruction);
                                           

                                            instructionIndex++;
                                            currentIndex++;
                                            //distanceReqForNextInst = instruction[instructionIndex-1].length;
                                            currentManeuverIndex++;
                                            
                                            return;
                                        }
                                        else{

                                            distanceReqForNextInst = instruction[instructionIndex-1].length;
                                            //console.log("distnace required : ", distanceReqForNextInst)

                                            const distanceCoordinates = calculateDistance(current_gps_lat, current_gps_lon, gps_lat, gps_lon);

                                            let turn = extractTurnType(instruction[currentManeuverIndex].instruction)


                                           //console.log("Index ", currentIndex-1, currentIndex);
                                           //console.log("Distance coordintaes : ", distanceCoordinates.toFixed(2) * 1000)
                                           //console.log("Distance for next instruction : ", distanceReqForNextInst.toFixed(2)*1000)
                                            totalDistanceTraveled = totalDistanceTraveled + distanceCoordinates;

                                            //if()
                                            document.getElementById('instructions-list').innerHTML = `<li>Turn ${turn} after  ${(distanceReqForNextInst.toFixed(2) * 1000) - (totalDistanceTraveled.toFixed(2) * 1000)}  m</li>`;
                                            //let turn_type = extractTurnType(instruction[currentManeuverIndex].verbal_post_transition_instruction)
                                            //document.getElementById('instructions-list').innerHTML = `<li>Turn ${turn_type} in ${(distanceReqForNextInst.toFixed(2) * 1000) - (totalDistanceTraveled.toFixed(2) * 1000)}  m</li>`;

                                           //console.log("total distance : ", totalDistanceTraveled);

                                        }

                                        
                                        if (parseFloat(totalDistanceTraveled.toFixed(3)) >= parseFloat(distanceReqForNextInst.toFixed(3))) {
                                            //console.log("Distance Travelled : ", totalDistanceTraveled, "Distance Required : ", distanceReqForNextInst);
                                            console.log("totalDistanceTraveled : ", totalDistanceTraveled.toFixed(3), " distanceReqForNextInst : ", distanceReqForNextInst.toFixed(3));

                                            displayInstructions(instruction[currentManeuverIndex].instruction, current_gps_lat, current_gps_lon, instruction[currentManeuverIndex].length, instruction[currentManeuverIndex].verbal_post_transition_instruction);

                                            totalDistanceTraveled = 0;
                                            //console.log("total distance : ", totalDistanceTraveled);
                                            currentManeuverIndex++;
                                            instructionIndex++;

                                        }
                                       
                                        
                                        
                                        /*
                                        if((distanceReqForNextInst.toFixed(3) * 1000)-(totalDistanceTraveled.toFixed(3) * 1000) <= 30){
                                            //console.log("Distance Travelled : ", totalDistanceTraveled, "Distance Required : ", distanceReqForNextInst);
                                            //displayInstructions(instruction[currentManeuverIndex].instruction, current_gps_lat, current_gps_lon, instruction[currentManeuverIndex].length, instruction[currentManeuverIndex].verbal_post_transition_instruction);
                                            
                                            //let turn_type = extractTurnType(instruction[currentManeuverIndex].verbal_post_transition_instruction)
                                           // document.getElementById('instructions-list').innerHTML = `<li>Turn ${turn_type} in ${(distanceReqForNextInst.toFixed(2) * 1000) - (totalDistanceTraveled.toFixed(2) * 1000)}  m</li>`;

                                            totalDistanceTraveled = 0;
                                            console.log("total distance : ", totalDistanceTraveled);
                                            currentManeuverIndex++;
                                            instructionIndex++;
                                        }
                                        */
                                        
                                    
                                   // }
  //[28.483078, 77.106181]

                                    current_gps_lat = gps_lat;
                                    current_gps_lon = gps_lon;

                                    //console.log("Corrindate swapped ");



                                    currentIndex++;
                                    
                                    
                             }






                             
                                 //const traffic_data = data.traffic;
                                 //console.log("Traffic : ", traffic_data);
                                 /*
                                 Intervals:
         
                                             Two intervals are set using setInterval:
                                             One for updating the marker's position based on the animation interval.
                                             Another for updating the marker's position and displaying instructions based on distance traveled.
                                 */
         
                                 
                                 //const instructionMarker = setInterval(updateInstruction, updateInterval);

                                 const updateMap = setInterval(() => {
                                    // Update map center to animatedMarker position
                                    map.panTo(animatedMarker.getLatLng());

                                
                                     centerLeafletMapOnMarker(map, animatedMarker);
                                     // Get the current marker position
                                     /* const markerLatLng = animatedMarker.getLatLng();
                                      // Get the next point on the path
                                    const nextPoint = pathCoordinates[currentIndex + 1];


                                    // Calculate the angle between the current marker position and the next point
                                    const angle = Math.atan2(nextPoint[1] - markerLatLng.lng, nextPoint[0] - markerLatLng.lat) * (180 / Math.PI);
                                    console.log("Angle : ", angle)

                                     // Set the map heading to the calculated angle
                                  

                                    // Rotate the map container based on the calculated angle
                                    const mapContainer = document.getElementById('map');
                                    mapContainer.style.transform = `rotate(${-angle}deg)`;
                                    
                                    */
                                

                                }, updateInterval);

                                 // Set inteval to update the given function in the give time
                                
                                  setInterval(() => {
                                    //if (currentIndex < pathCoordinates.length) {
                                        //console.log("Inside moving setInterval");

                                       console.log("Current coordinates : ", current_gps_lat, " ---- ", current_gps_lon)
                                        animatedMarker.setLatLng([current_gps_lat, current_gps_lon]);
                                        traveledPathPolyline.addLatLng([current_gps_lat, current_gps_lon]);

                                        //map.fitBounds(animatedMarker.getBounds())

                                        //console.log("currentIndex : ", currentIndex);
                                        //coordinateIndex++;
                                    //}
                                }, updateInterval);
                                
                                

                                 //const markerUpdate = setInterval(updateMarkerPosition, updateGeoLocation);
                                 //clearInterval(markerUpdate);
                             })
                             .catch((error) => {
                                 console.error('Error: ', error);
                             });
                         })
                         .catch(error => console.error('Error:', error));
                
         }
      </script>
   </body>
</html>
